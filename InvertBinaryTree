Given the root of a binary tree, invert the tree, and return its root.


Example 1:


Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
Example 2:


Input: root = [2,1,3]
Output: [2,3,1]
Example 3:

Input: root = []
Output: []
 

Constraints:

The number of nodes in the tree is in the range [0, 100].
-100 <= Node.val <= 100


Solution:

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root: #base case as terminating condition when we've reached bottom of tree. Returns None if there is not another node below the current node and applies to both the left and right tree.
            return None
        #Swap the left and right children of the current Node
        #root.right overtakes root.left, and root.left overtakes root.right
        root.left, root.right = root.right, root.left
        #Recursively invert the left and right subtrees
        self.invertTree(root.left) 
        self.invertTree(root.right)     
        return root
        
 #if the three is 
 #.      a
 #      b c
 #.    d e f
 # we are flipping the 2nd level, and then we are flipping the 2nd level's children, and we keep doing this until we reach the bottom
 #       a
 #      c b
 #.    d e f
